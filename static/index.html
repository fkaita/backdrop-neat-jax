<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scatter Plot with NEAT Classification</title>
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
</head>
<body>
<div class="container">
  <div class="row">
    <div class="col-sm-6 text-center">
      <div class="container-fluid text-center" id="p5Container">
        <div id="scatterPlot" style="width: 100%; height: 500px;"></div>
      </div>

      <div class="panel-body text-center" id="customDataBox" style="display: none;">
        <a class="btn btn-warning btn-sm" id="customDataOrange">Orange Point</a>
        <a class="btn btn-primary btn-sm" id="customDataBlue">Blue Point</a>
        <a class="btn btn-success btn-sm" id="customDataSubmit">Submit Data</a>
      </div>

      <div class="panel-body text-center">
        <a class="btn btn-danger btn-sm" id="backpropButton">Run Backpropagation</a>
      </div>
    </div>
  </div>
</div>

<script>
$(document).ready(function () {
  // Function to fetch dataset from the server
  function fetchDataset(type, trainSize, noise) {
    return $.ajax({
      url: '/generate_data',
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({ type, train_size: trainSize, noise }),
    });
  }

  // Function to get NEAT model predictions
  function fetchNEATPredictions(inputs) {
    return $.ajax({
      url: '/forward',
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({ genome_index: 0, inputs }),
    });
  }

  // Function to run backpropagation
  function runBackprop(inputs, labels, nSteps = 100, learningRate = 0.05) {
    return $.ajax({
      url: '/backprop',
      method: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({
        genome_index: 0,
        inputs,
        labels,
        n_steps: nSteps,
        lr: learningRate
      }),
    });
  }

  // Function to generate background prediction grid
  function generatePredictionGrid(xRange, yRange, resolution) {
    const grid = [];
    for (let x = xRange[0]; x <= xRange[1]; x += resolution) {
      for (let y = yRange[0]; y <= yRange[1]; y += resolution) {
        grid.push([x, y]);
      }
    }
    return grid;
  }

  // Function to plot the scatter plot
  function plotScatter(data, predictions = null, background = null) {
    const trainX = data.train_x;
    const trainLabels = data.train_label;

    // Separate data by class
    const class0 = trainX.filter((_, i) => trainLabels[i] === 0);
    const class1 = trainX.filter((_, i) => trainLabels[i] === 1);

    // Create traces
    const trace0 = {
      x: class0.map(point => point[0]),
      y: class0.map(point => point[1]),
      mode: 'markers',
      marker: { color: 'blue' },
      name: 'Class 0 (True)',
    };

    const trace1 = {
      x: class1.map(point => point[0]),
      y: class1.map(point => point[1]),
      mode: 'markers',
      marker: { color: 'orange' },
      name: 'Class 1 (True)',
    };

    const traces = [trace0, trace1];

    // Add background gradation for model predictions
    if (background) {
      traces.push({
        x: background.x,
        y: background.y,
        z: background.z,
        type: 'contour',
        colorscale: 'Viridis',
        showscale: false,
        name: 'Prediction Background',
      });
    }

    // If predictions are provided, add predicted classes to the plot
    if (predictions) {
      const predClass0 = trainX.filter((_, i) => predictions[i][0] < 0.5);
      const predClass1 = trainX.filter((_, i) => predictions[i][0] >= 0.5);

      traces.push({
        x: predClass0.map(point => point[0]),
        y: predClass0.map(point => point[1]),
        mode: 'markers',
        marker: { color: 'green', symbol: 'x' },
        name: 'Class 0 (Predicted)',
      });

      traces.push({
        x: predClass1.map(point => point[0]),
        y: predClass1.map(point => point[1]),
        mode: 'markers',
        marker: { color: 'red', symbol: 'x' },
        name: 'Class 1 (Predicted)',
      });
    }

    const layout = {
      title: 'Scatter Plot with NEAT Classification',
      xaxis: { title: 'X-axis' },
      yaxis: { title: 'Y-axis' },
    };

    // Render the plot
    Plotly.newPlot('scatterPlot', traces, layout);
  }

  // Fetch and display dataset when page loads
  fetchDataset('circle', 200, 0.5)
    .done(data => {
      const grid = generatePredictionGrid([-6, 6], [-6, 6], 0.2);
      fetchNEATPredictions(grid)
        .done(predictions => {
          const background = {
            x: grid.map(p => p[0]),
            y: grid.map(p => p[1]),
            z: predictions.outputs.map(p => p[0]),
          };

          plotScatter(data, predictions.outputs, background);

          // Add backpropagation button functionality
          $('#backpropButton').on('click', function () {
            runBackprop(data.train_x, data.train_label)
              .done(response => {
                console.log(response.msg);
                // Re-fetch predictions and update the plot
                fetchNEATPredictions(data.train_x)
                  .done(newPredictions => {
                    plotScatter(data, newPredictions.outputs, background);
                  });
              })
              .fail(err => {
                console.error('Error running backpropagation:', err);
              });
          });
        })
        .fail(err => {
          console.error('Error fetching predictions:', err);
          plotScatter(data);
        });
    })
    .fail(err => {
      console.error('Error fetching data:', err);
    });
});
</script>
</body>
</html>
